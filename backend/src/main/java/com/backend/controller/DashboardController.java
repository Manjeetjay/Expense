package com.backend.controller;

import com.backend.model.Expense;
import com.backend.model.MonthlyBudget;
import com.backend.repository.ExpenseRepository;
import com.backend.repository.MonthlyBudgetRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.time.YearMonth;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

@RestController
@CrossOrigin(origins = "http://localhost:5173")
@RequestMapping("/api/dashboard")
public class DashboardController {

    @Autowired
    private ExpenseRepository expenseRepository;

    @Autowired
    private MonthlyBudgetRepository monthlyBudgetRepository;

    @GetMapping("/expenses")
    public ResponseEntity<Page<Expense>> getExpenses(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "18") int size,
            @RequestParam(required = false) String sortBy,
            @RequestParam(required = false) String sortDir,
            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime startDate,
            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime endDate
    ) {
        Sort sort = Sort.unsorted();
        if (sortBy != null) {
            sort = Sort.by(sortDir != null && sortDir.equalsIgnoreCase("desc") ? 
                          Sort.Direction.DESC : Sort.Direction.ASC, sortBy);
        }

        PageRequest pageRequest = PageRequest.of(page, size, sort);

        Page<Expense> expenses;
        if (startDate != null && endDate != null) {
            expenses = expenseRepository.findAllByDateBetween(startDate, endDate, pageRequest);
        } else {
            expenses = expenseRepository.findAll(pageRequest);
        }

        return ResponseEntity.ok(expenses);
    }

    @PostMapping("/budget")
    public ResponseEntity<?> setBudget(@RequestBody MonthlyBudget budget) {
        try {
            YearMonth currentMonth = YearMonth.now();
            
            // Check if budget already exists
            Optional<MonthlyBudget> existingBudget = monthlyBudgetRepository
                .findByYearMonth(currentMonth.toString());
            
            if (existingBudget.isPresent()) {
                return ResponseEntity
                    .badRequest()
                    .body("Budget already set for " + currentMonth.getMonth().toString());
            }
            
            budget.setYearMonth(currentMonth);
            budget.setAutoGenerated(false);
            MonthlyBudget saved = monthlyBudgetRepository.save(budget);
            return ResponseEntity.ok(saved);
        } catch (Exception e) {
            return ResponseEntity.internalServerError()
                .body("Error setting budget: " + e.getMessage());
        }
    }

    @GetMapping("/summary")
    public ResponseEntity<?> getMonthlySummary() {
        try {
            YearMonth currentMonth = YearMonth.now();
            LocalDateTime startOfMonth = currentMonth.atDay(1).atStartOfDay();
            LocalDateTime endOfMonth = currentMonth.atEndOfMonth().atTime(23, 59, 59);

            // Get current month's budget or create from last month
            MonthlyBudget currentBudget = monthlyBudgetRepository.findByYearMonth(currentMonth)
                .orElseGet(() -> {
                    // Try to get last month's budget
                    MonthlyBudget lastBudget = monthlyBudgetRepository.findByYearMonth(currentMonth.minusMonths(1))
                        .orElse(null);
                    
                    if (lastBudget != null) {
                        MonthlyBudget newBudget = new MonthlyBudget();
                        newBudget.setAmount(lastBudget.getAmount());
                        newBudget.setYearMonth(currentMonth);
                        newBudget.setAutoGenerated(true);
                        return monthlyBudgetRepository.save(newBudget);
                    }
                    return new MonthlyBudget();
                });

            Double currentMonthExpenses = expenseRepository.getTotalExpensesBetween(startOfMonth, endOfMonth);
            Double allTimeExpenses = expenseRepository.getTotalExpenses();
            Double allTimeBudget = monthlyBudgetRepository.getTotalBudget();

            Map<String, Object> response = new HashMap<>();
            response.put("currentMonth", Map.of(
                "budget", currentBudget.getAmount() != null ? currentBudget.getAmount() : 0.0,
                "expenses", currentMonthExpenses != null ? currentMonthExpenses : 0.0,
                "remaining", (currentBudget.getAmount() != null ? currentBudget.getAmount() : 0.0) - 
                            (currentMonthExpenses != null ? currentMonthExpenses : 0.0),
                "isAutoGenerated", currentBudget.isAutoGenerated()
            ));
            response.put("allTime", Map.of(
                "totalBudget", allTimeBudget != null ? allTimeBudget : 0.0,
                "totalExpenses", allTimeExpenses != null ? allTimeExpenses : 0.0
            ));

            return ResponseEntity.ok(response);
        } catch (Exception e) {
            return ResponseEntity.internalServerError()
                .body("Error fetching summary: " + e.getMessage());
        }
    }

    @PostMapping("/cleanup-budgets")
    public ResponseEntity<?> cleanupDuplicateBudgets() {
        try {
            Map<YearMonth, List<MonthlyBudget>> budgetsByMonth = monthlyBudgetRepository.findAll()
                .stream()
                .collect(Collectors.groupingBy(MonthlyBudget::getYearMonth));

            int removed = 0;
            for (Map.Entry<YearMonth, List<MonthlyBudget>> entry : budgetsByMonth.entrySet()) {
                List<MonthlyBudget> budgets = entry.getValue();
                if (budgets.size() > 1) {
                    // Keep the first budget and delete others
                    budgets.stream()
                        .skip(1)
                        .forEach(b -> monthlyBudgetRepository.deleteById(b.getId()));
                    removed += budgets.size() - 1;
                }
            }

            return ResponseEntity.ok("Removed " + removed + " duplicate budgets");
        } catch (Exception e) {
            return ResponseEntity.internalServerError()
                .body("Error cleaning up budgets: " + e.getMessage());
        }
    }
} 